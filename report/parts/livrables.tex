
\section{Livrables}

\subsection{Étape 1}

Pour ce premier livrable, nous devons pouvoir créer un graphe en
mémoire, et effectuer un parcours en largeur de profondeur arbitraire
dessus -- en notant bien que « afficher le graphe entier » revient à
faire un parcours « jusqu'au bout ». Le fichier de test pour ce
livrable est \texttt{src/examples/main1.cc}.

Le code est relativement auto-explicatif, mais pour rappel, il
effectue dans l'ordre les choses suivantes :

\begin{itemize}
\item On définit un graphe étiqueté par des réels, ainsi qu'une classe
  d'entrée permettant de remplir le graphe à partir d'un fichier.
\item On remplit le graphe selon le contenu du fichier \texttt{test.yolo}.
\item On définit un singleton de calcul.
\item On affiche le résultat des différents parcours demandés.
\item On définit une classe de sortie permettant d'obtenir un fichier
  sous format Dot, pour finalement récupérer \texttt{truc.dot}.
\end{itemize}

Les seuls points un peu exotiques de ce code sont cette fonction :

\begin{minted}{c++}
  bool true__(Edge<double>& e) { (void)e; return true; }
\end{minted}

qui est en fait un filtre vide pour les parcours (le compilateur a la
facheuse tendance à se plaindre lorsque des variables sont inutilisées).

\subsection{Étapes 2 à 4}

Pour ces livrables, nous avons ajouté les fonctionnalités suivantes :

\begin{itemize}
\item Une spécialisation de nos graphes pour une modélisation de
  routes/chemins de fers/voies aériennes (afin de mieux coller au sujet).
\item Un nettoyage des filtres (notemment sur leur syntaxe), et
  l'ajout d'un DSL\footnote{Domain-Specific Language} pour pouvoir les
  combiner entre eux.
\item Des tests, situés toujours dans \texttt{src/examples}
  correspondant à chacun des livrables.
\item Un semblant d'UI\footnote{User Interface} pour les exemples.
\end{itemize} 

Tous les changements apportés au projet sont répertoriés et datés dans
le graphe de commits du projet, disponible ici :
\url{https://github.com/Thooms/yolo-graphs/commits/master}
